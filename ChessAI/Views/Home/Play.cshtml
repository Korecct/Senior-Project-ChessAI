@model ChessAI.Controllers.HomeController.PlayViewModel
@using ChessAI.Models.AIs
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Antiforgery

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
    <input type="hidden" id="RequestVerificationToken" value="@Antiforgery.GetAndStoreTokens(ViewContext.HttpContext).RequestToken" />

    <div class="main-container">
        <div class="chess-board-container">
            <!-- GameResult Modal -->
            <div id="gameResultModal" class="game-result-modal" style="display: none;">
                <div class="game-result-content">
                    <span id="gameResultMessage" class="game-result-message"></span>
                    <div class="modal-buttons">
                        <button type="button" class="restart-button" onclick="restartGame()">Restart</button>
                        <button type="button" class="close-button" onclick="closeGameResultModal()">Close</button>
                    </div>
                </div>
            </div>

            <div class="chess-board @(Model.GameMode == "PvAI" && string.IsNullOrEmpty(ViewBag.SelectedAI) ? "disabled" : "")" id="chessBoard">
                @for (int row = 0; row < 8; row++)
                {
                    @for (int col = 0; col < 8; col++)
                    {
                        var isBlack = (row + col) % 2 == 0;
                        var className = isBlack ? "black" : "white";
                        var piece = Model.Game.Board.Squares[row][col];
                        var pieceSymbol = "";
                        if (piece != null)
                        {
                            pieceSymbol = GetPieceSymbol(piece);
                        }
                        <div class="chess-square @className"
                             data-row="@row" data-col="@col"
                             onclick="squareClick(event)">
                            @if (!string.IsNullOrEmpty(pieceSymbol))
                            {
                                <div class="chess-piece @(piece.IsWhite ? "white-piece" : "black-piece")"
                                     data-piece="@pieceSymbol" data-row="@row" data-col="@col"
                                     data-piece-type="@piece.GetType().Name"
                                     data-piece-color="@(piece.IsWhite ? "white" : "black")"
                                     onmousedown="pieceMouseDown(event)">
                                    @pieceSymbol
                                </div>
                            }
                        </div>
                    }
                }
            </div>
        </div>

        <div class="side-panel">
            <!-- GameMode Indicator -->
            <div class="game-mode-indicator">
                <span>Current Mode:</span>
                <strong>@Model.GameMode</strong>
                @if (Model.GameMode == "PvAI" && !string.IsNullOrEmpty(Model.SelectedAI))
                {
                    <span> - AI: <strong>@Model.SelectedAI</strong></span>
                }
            </div>

            <!-- Turn Indicator -->
            <div class="turn-mode-indicator" id="turnIndicator">
                @if (Model.Game.IsGameOver)
                {
                    <span>Game Over</span>
                }
                else
                {
                    <span>It's <strong>@(Model.IsWhiteTurn ? "White's" : "Black's")</strong> turn.</span>
                    @if (Model.IsWhiteKingInCheck)
                    {
                        <div class="check-indicator">White king is in check!</div>
                    }
                    @if (Model.IsBlackKingInCheck)
                    {
                        <div class="check-indicator">Black king is in check!</div>
                    }
                }
            </div>

            <!-- AI Selection UI (only visible in PvAI mode) -->
            @if (Model.GameMode == "PvAI")
            {
                <div class="ai-selection-container">
                    <label for="aiSelect">Choose AI:</label>
                    <select id="aiSelect" name="aiSelect">
                        <option value="">-- Select an AI --</option>
                        @foreach (var ai in AIFactory.GetAllAIPlayers())
                        {
                            <option value="@ai.Name">@ai.Name</option>
                        }
                    </select>
                    <button type="button" class="ai-button" onclick="selectAIAndStartGame()">Start Game</button>
                    <button type="button" class="ai-button" onclick="setGameMode('PvAI')">Restart</button>
                </div>
            }

            <!-- PvP Selection UI (only visible in PvP mode) -->
            @if (Model.GameMode == "LocalPvP")
            {
                <div class="ai-selection-container">
                    <button type="button" class="ai-button" onclick="setGameMode('LocalPvP')">Restart</button>
                </div>
            }

            <div class="gamemode-button-container">
                <button type="button" class="gamemode-button @(Model.GameMode == "Tutorial" ? "active" : "")" name="Tutorial" onclick="setGameMode('Tutorial')">Tutorial</button>
                <button type="button" class="gamemode-button @(Model.GameMode == "LocalPvP" ? "active" : "")" name="Local PvP" onclick="setGameMode('LocalPvP')">Local PvP</button>
                <button type="button" class="gamemode-button @(Model.GameMode == "PvAI" ? "active" : "")" name="PvAI" onclick="setGameMode('PvAI')">PvAI</button>
            </div>
        </div>
    </div>

    <script>
        let selectedPiece = null;
        let offsetX, offsetY;
        let originalSquare = null;
        let isGameBusy = false;

        function pieceMouseDown(event) {
            if (@Model.Game.IsGameOver.ToString().ToLower() || isGameBusy) {
                // Prevent moving pieces if the game is over or if AI is busy
                return;
            }
            let isWhiteTurn = @Model.Game.IsWhiteTurn.ToString().ToLower();
            const pieceColor = event.target.getAttribute('data-piece-color');

            if ((isWhiteTurn === 'true' && pieceColor !== 'white') || (isWhiteTurn === 'false' && pieceColor !== 'black')) {
                // Not this player's turn
                return;
            }

            selectedPiece = event.target;
            originalSquare = selectedPiece.parentElement;

            // Get the mouse position relative to the piece
            const rect = selectedPiece.getBoundingClientRect();
            offsetX = event.clientX - rect.left;
            offsetY = event.clientY - rect.top;

            selectedPiece.style.zIndex = 1000;

            document.addEventListener('mousemove', documentMouseMove);
            document.addEventListener('mouseup', documentMouseUp);

            // Highlight possible moves
            const fromRow = parseInt(selectedPiece.getAttribute('data-row'));
            const fromCol = parseInt(selectedPiece.getAttribute('data-col'));

            getValidMoves(fromRow, fromCol);

            event.preventDefault();
        }

        function documentMouseMove(event) {
            if (selectedPiece) {
                moveAt(event.clientX, event.clientY);
            }
        }

        function moveAt(clientX, clientY) {
            const parentRect = originalSquare.getBoundingClientRect();

            const x = clientX - parentRect.left - offsetX;
            const y = clientY - parentRect.top - offsetY;

            selectedPiece.style.left = x + 'px';
            selectedPiece.style.top = y + 'px';
        }

        function documentMouseUp(event) {
            if (selectedPiece) {
                // Get the square under the cursor
                const elements = document.elementsFromPoint(event.clientX, event.clientY);
                const square = elements.find(el => el.classList.contains('chess-square'));

                if (square && square.classList.contains('highlight')) {
                    const fromRow = parseInt(selectedPiece.getAttribute('data-row'));
                    const fromCol = parseInt(selectedPiece.getAttribute('data-col'));
                    const toRow = parseInt(square.getAttribute('data-row'));
                    const toCol = parseInt(square.getAttribute('data-col'));

                    postMove(fromRow, fromCol, toRow, toCol);
                } else {
                    // Move back to original position
                    resetPiecePosition(selectedPiece);
                }

                clearHighlights();
                document.removeEventListener('mousemove', documentMouseMove);
                document.removeEventListener('mouseup', documentMouseUp);
                selectedPiece = null;
                originalSquare = null;
            }
        }

        function resetPiecePosition(piece) {
            piece.style.left = '';
            piece.style.top = '';
            piece.style.zIndex = '';
        }

        function squareClick(event) {
            if (!selectedPiece) {
                // No piece selected
                return;
            }

            const fromRow = parseInt(selectedPiece.getAttribute('data-row'));
            const fromCol = parseInt(selectedPiece.getAttribute('data-col'));
            const toRow = parseInt(event.currentTarget.getAttribute('data-row'));
            const toCol = parseInt(event.currentTarget.getAttribute('data-col'));

            // Only allow moving to highlighted squares
            if (!event.currentTarget.classList.contains('highlight')) {
                return;
            }

            postMove(fromRow, fromCol, toRow, toCol);
            clearHighlights();
            selectedPiece = null;
        }

        function getValidMoves(row, col) {
            fetch('/Home/GetValidMoves', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': document.getElementById('RequestVerificationToken').value
                },
                body: JSON.stringify({ row: row, col: col })
            }).then(response => {
                if (response.ok) {
                    return response.json();
                } else {
                    return Promise.reject('Failed to fetch valid moves.');
                }
            }).then(validMoves => {
                highlightValidMoves(validMoves);
            }).catch(error => {
                console.error('Error:', error);
            });
        }

        function highlightValidMoves(moves) {
            moves.forEach(move => {
                const row = move.Row !== undefined ? move.Row : move.row;
                const col = move.Col !== undefined ? move.Col : move.col;
                const selector = `.chess-square[data-row='${row}'][data-col='${col}']`;
                const square = document.querySelector(selector);
                if (square) {
                    square.classList.add('highlight');
                }
            });
        }

        function clearHighlights() {
            const highlightedSquares = document.querySelectorAll('.chess-square.highlight');
            highlightedSquares.forEach(square => {
                square.classList.remove('highlight');
            });
        }

        function playSound(event) {
            const soundElement = document.getElementById(`sound${event}`);
            if (soundElement) {
                // Reset for imediate replay
                soundElement.currentTime = 0;
                soundElement.play();
            }
        }

        function updateTurnIndicator(isWhiteTurn, isWhiteKingInCheck, isBlackKingInCheck, isGameOver, message) {
            const turnIndicator = document.getElementById('turnIndicator');
            if (isGameOver) {
                turnIndicator.innerHTML = '<span>Game Over</span>';
            } else if (message) {
                turnIndicator.innerHTML = `<span>${message}</span>`;
            } else {
                let html = `<span>It's <strong>${isWhiteTurn === true ? "White's" : "Black's"}</strong> turn.</span>`;
                if (isWhiteKingInCheck) {
                    html += '<div class="check-indicator">White king is in check!</div>';
                }
                if (isBlackKingInCheck) {
                    html += '<div class="check-indicator">Black king is in check!</div>';
                }
                turnIndicator.innerHTML = html;
            }
        }

        async function postMove(fromRow, fromCol, toRow, toCol) {
            if (isGameBusy) {
                return;
            }
            isGameBusy = true;

            try {
                const response = await fetch('/Home/MakeMove', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.getElementById('RequestVerificationToken').value
                    },
                    body: JSON.stringify({ fromRow, fromCol, toRow, toCol })
                });

                if (!response.ok) {
                    throw new Error('Invalid move.');
                }

                const data = await response.json();

                if (data.success) {
                    // Move the players piece in the UI
                    movePieceInUI(fromRow, fromCol, toRow, toCol, data);

                    // Play sound for player's move
                    playPlayerMoveSound(data);

                    // Check for game over after player's move
                    if (data.isGameOver) {
                        handleGameOver(data.gameResult);
                        isGameBusy = false; // Game over
                        return;
                    }

                    // handle AI movement if exists
                    if (data.aiMove) {
                        // Update the turn indicator to show that it's the AI's turn
                        updateTurnIndicator(null, null, null, false, "AI is thinking...");

                        // Delay before AI moves
                        setTimeout(() => {
                            // Animate the AI's move
                            makeAIMove(data.aiMove.from, data.aiMove.to, data);

                            updateTurnIndicator(data.isWhiteTurn, data.isWhiteKingInCheck, data.isBlackKingInCheck, data.isGameOver);

                            // After AI's move is done, allow player interaction
                            isGameBusy = false;

                        }, 1000); // Delay 1 second before AI moves
                    } else {
                        // No AI move, update the turn indicator
                        updateTurnIndicator(data.isWhiteTurn, data.isWhiteKingInCheck, data.isBlackKingInCheck, data.isGameOver);
                        isGameBusy = false;
                    }

                } else {
                    alert('Invalid move.');
                    resetPiecePosition(selectedPiece);
                    isGameBusy = false;
                }
            } catch (error) {
                console.error('Error:', error);
                alert('An error occurred while making the move.');
                resetPiecePosition(selectedPiece);
                isGameBusy = false;
            }
        }

        function movePieceInUI(fromRow, fromCol, toRow, toCol, data) {
            const fromSquare = document.querySelector(`.chess-square[data-row='${fromRow}'][data-col='${fromCol}']`);
            const toSquare = document.querySelector(`.chess-square[data-row='${toRow}'][data-col='${toCol}']`);

            if (fromSquare && toSquare) {
                const piece = fromSquare.querySelector('.chess-piece');
                if (piece) {
                    // Remove any piece at the destination (for captures)
                    const capturedPiece = toSquare.querySelector('.chess-piece');
                    if (capturedPiece) {
                        capturedPiece.remove();
                    }

                    // Move the piece to the new square
                    toSquare.appendChild(piece);
                    // Update the piece's data attributes
                    piece.setAttribute('data-row', toRow);
                    piece.setAttribute('data-col', toCol);
                    // Reset piece styles
                    resetPiecePosition(piece);

                    // Pawn Promotion
                    if (data.playerIsPromotion) {
                        // Update piece symbol to Queen
                        const isWhite = piece.getAttribute('data-piece-color') === 'white';
                        const queenSymbol = isWhite ? '♕' : '♛';
                        piece.textContent = queenSymbol;

                        // Update data attributes
                        piece.setAttribute('data-piece-type', 'Queen');
                        piece.setAttribute('data-piece', queenSymbol);
                    }

                    // En Passant
                    if (data.playerIsEnPassantCapture) {
                        const capturedPawnRow = piece.getAttribute('data-piece-color') === 'white' ? toRow + 1 : toRow - 1;
                        const capturedPawnSquare = document.querySelector(`.chess-square[data-row='${capturedPawnRow}'][data-col='${toCol}']`);
                        const capturedPawn = capturedPawnSquare.querySelector('.chess-piece');
                        if (capturedPawn) {
                            capturedPawn.remove();
                        }
                    }

                    // Castling
                    if (data.playerIsCastle) {
                        const isKingsideCastle = toCol > fromCol;
                        const rookFromCol = isKingsideCastle ? 7 : 0;
                        const rookToCol = isKingsideCastle ? toCol - 1 : toCol + 1;
                        const rookRow = fromRow;
                        const rookFromSquare = document.querySelector(`.chess-square[data-row='${rookRow}'][data-col='${rookFromCol}']`);
                        const rookToSquare = document.querySelector(`.chess-square[data-row='${rookRow}'][data-col='${rookToCol}']`);
                        const rookPiece = rookFromSquare.querySelector('.chess-piece');
                        if (rookPiece) {
                            rookToSquare.appendChild(rookPiece);
                            rookPiece.setAttribute('data-row', rookRow);
                            rookPiece.setAttribute('data-col', rookToCol);
                        }
                    }
                }
            }
        }


        function playPlayerMoveSound(data) {
            if (data.playerIsCheckmate) {
                playSound('Checkmate');
            } else if (data.playerIsCheck) {
                playSound('Check');
            } else if (data.playerIsCastle) {
                playSound('Castle');
            } else if (data.playerIsCapture || data.playerIsEnPassantCapture) {
                playSound('Capture');
            } else if (data.playerIsPromotion) {
                playSound('Promotion');
            } else {
                playSound('Move');
            }
        }

        function playAIMoveSound(data) {
            if (data.aiIsCheckmate) {
                playSound('Checkmate');
            } else if (data.aiIsCheck) {
                playSound('Check');
            } else if (data.aiIsCastle) {
                playSound('Castle');
            } else if (data.aiIsCapture || data.aiIsEnPassantCapture) {
                playSound('Capture');
            } else if (data.aiIsPromotion) {
                playSound('Promotion');
            } else {
                playSound('Move');
            }
        }

        function makeAIMove(from, to, data) {
            const fromSquare = document.querySelector(`.chess-square[data-row='${from.row}'][data-col='${from.col}']`);
            const toSquare = document.querySelector(`.chess-square[data-row='${to.row}'][data-col='${to.col}']`);

            if (fromSquare && toSquare) {
                const piece = fromSquare.querySelector('.chess-piece');
                if (piece) {
                    // Remove any piece at the destination (for captures)
                    const capturedPiece = toSquare.querySelector('.chess-piece');
                    if (capturedPiece) {
                        capturedPiece.remove();
                    }

                    // Move the piece to the new square
                    toSquare.appendChild(piece);
                    // Update the piece's data attributes
                    piece.setAttribute('data-row', to.row);
                    piece.setAttribute('data-col', to.col);

                    // Handle Pawn Promotion
                    if (data.aiIsPromotion) {
                        const isWhite = piece.getAttribute('data-piece-color') === 'white';
                        const queenSymbol = isWhite ? '♕' : '♛';
                        piece.textContent = queenSymbol;
                        piece.setAttribute('data-piece-type', 'Queen');
                        piece.setAttribute('data-piece', queenSymbol);
                    }

                    // Handle En Passant
                    if (data.aiIsEnPassantCapture) {
                        const capturedPawnRow = piece.getAttribute('data-piece-color') === 'white' ? to.row + 1 : to.row - 1;
                        const capturedPawnSquare = document.querySelector(`.chess-square[data-row='${capturedPawnRow}'][data-col='${to.col}']`);
                        const capturedPawn = capturedPawnSquare.querySelector('.chess-piece');
                        if (capturedPawn) {
                            capturedPawn.remove();
                        }
                    }
                    
                    // Handle Castling
                    if (data.aiIsCastle) {
                        const isKingsideCastle = to.col > from.col;
                        const rookFromCol = isKingsideCastle ? 7 : 0;
                        const rookToCol = isKingsideCastle ? to.col - 1 : to.col + 1;
                        const rookRow = from.row;
                        const rookFromSquare = document.querySelector(`.chess-square[data-row='${rookRow}'][data-col='${rookFromCol}']`);
                        const rookToSquare = document.querySelector(`.chess-square[data-row='${rookRow}'][data-col='${rookToCol}']`);
                        const rookPiece = rookFromSquare.querySelector('.chess-piece');
                        if (rookPiece) {
                            rookToSquare.appendChild(rookPiece);
                            rookPiece.setAttribute('data-row', rookRow);
                            rookPiece.setAttribute('data-col', rookToCol);
                        }
                    }

                    // Pawn promotion and check sounds do not play when checking the AI, needs fix
                    // Play AI move sound
                    playAIMoveSound(data);

                    // Check for game over after AI's move
                    if (data.isGameOver) {
                        handleGameOver(data.gameResult);
                    }
                }
            }
        }

        function handleGameOver(gameResult) {
            // Play corresponding sound
            // Needs sounds for these
            if (gameResult.includes("wins")) {
                playSound('Victory');
            } else if (gameResult.includes("draw") || gameResult.includes("stalemate")) {
                playSound('Stalemate');
            } else {
                playSound('Defeat');
            }

            // Display the game result in the modal
            showGameResultModal(gameResult);
        }

        function showGameResultModal(message) {
            const modal = document.getElementById('gameResultModal');
            const messageElement = document.getElementById('gameResultMessage');
            messageElement.textContent = message;
            modal.style.display = 'flex';
        }

        function closeGameResultModal() {
            const modal = document.getElementById('gameResultModal');
            modal.style.display = 'none';
        }

        function restartGame() {
            const restartButton = document.querySelector('.restart-button');
            if (restartButton) {
                restartButton.disabled = true;
                restartButton.textContent = 'Restarting...';
            }

            fetch('/Home/RestartGame', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': document.getElementById('RequestVerificationToken').value
                }
            }).then(response => {
                if (response.ok) {
                    // Reload the page to start a new game
                    window.location.reload();
                } else {
                    alert('Failed to restart the game.');
                    if (restartButton) {
                        restartButton.disabled = false;
                        restartButton.textContent = 'Restart';
                    }
                }
            }).catch(error => {
                console.error('Error:', error);
                alert('An error occurred while restarting the game.');
                if (restartButton) {
                    restartButton.disabled = false;
                    restartButton.textContent = 'Restart';
                }
            });
        }


        // Close the modal when clicking outside the content
        window.onclick = function (event) {
            const modal = document.getElementById('gameResultModal');
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }

        function selectAIAndStartGame() {
            const aiName = document.getElementById('aiSelect').value;
            if (!aiName) {
                alert('Please select an AI to start the game.');
                return;
            }

            fetch('/Home/SelectAI', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': document.getElementById('RequestVerificationToken').value
                },
                body: JSON.stringify({ AIName: aiName })
            }).then(response => {
                if (response.ok) {
                    // Reload the page to start the game
                    window.location.reload();
                } else {
                    alert('Failed to select AI.');
                }
            }).catch(error => {
                console.error('Error:', error);
                alert('An error occurred while selecting the AI.');
            });
        }

        // Set game mode when gamemode buttons are pressed
        function setGameMode(mode) {
            fetch('/Home/SetGameMode', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': document.getElementById('RequestVerificationToken').value
                },
                body: JSON.stringify({ GameMode: mode })
            }).then(response => {
                if (response.ok) {
                    // Reload the page to apply changes
                    window.location.reload();
                } else {
                    alert('Failed to set game mode.');
                }
            }).catch(error => {
                console.error('Error:', error);
                alert('An error occurred while setting the game mode.');
            });
        }
    </script>

    @functions {
        private string GetPieceSymbol(Piece piece)
        {
            if (piece is Pawn)
                return piece.IsWhite ? "♙" : "♟";
            else if (piece is Rook)
                return piece.IsWhite ? "♖" : "♜";
            else if (piece is Knight)
                return piece.IsWhite ? "♘" : "♞";
            else if (piece is Bishop)
                return piece.IsWhite ? "♗" : "♝";
            else if (piece is Queen)
                return piece.IsWhite ? "♕" : "♛";
            else if (piece is King)
                return piece.IsWhite ? "♔" : "♚";
            else
                return "";
        }
    }

    <!-- Loads Sounds -->
    <audio id="soundMove" src="/sounds/move.mp3" preload="auto"></audio>
    <audio id="soundCheck" src="/sounds/check.mp3" preload="auto"></audio>
    <audio id="soundCheckmate" src="/sounds/checkmate.mp3" preload="auto"></audio>
    <audio id="soundCastle" src="/sounds/castle.mp3" preload="auto"></audio>
    <audio id="soundCapture" src="/sounds/capture.mp3" preload="auto"></audio>
    <audio id="soundPromotion" src="/sounds/promotion.mp3" preload="auto"></audio>
    <audio id="soundVictory" src="/sounds/victory.mp3" preload="auto"></audio>
    <audio id="soundStalemate" src="/sounds/stalemate.mp3" preload="auto"></audio>
    <audio id="soundDefeat" src="/sounds/defeat.mp3" preload="auto"></audio>

</body>
</html>