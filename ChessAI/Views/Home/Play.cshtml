@model ChessAI.Controllers.HomeController.PlayViewModel
@using ChessAI.Models.AIs
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Antiforgery

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="~/css/site.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- SignalR-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.7/signalr.min.js"></script>
</head>
<body>
    <input type="hidden" id="RequestVerificationToken" value="@Antiforgery.GetAndStoreTokens(ViewContext.HttpContext).RequestToken" />

    <div class="main-container">
        <div class="chess-board-container">
            <!-- GameResult Modal -->
            <div id="gameResultModal" class="game-result-modal" style="display: none;">
                <div class="game-result-content">
                    <span id="gameResultMessage" class="game-result-message"></span>
                    <div class="modal-buttons">
                        <button type="button" class="restart-button" onclick="restartGame()">Rematch</button>
                        <button type="button" class="close-button" onclick="closeGameResultModal()">Close</button>
                    </div>
                </div>
            </div>

            <div class="chess-board @(Model.GameMode == "PvAI" && string.IsNullOrEmpty(ViewBag.SelectedAI) ? "disabled" : "")" id="chessBoard">
                @for (int row = 0; row < 8; row++)
                {
                    @for (int col = 0; col < 8; col++)
                    {
                        var isBlack = (row + col) % 2 == 0;
                        var className = isBlack ? "black" : "white";
                        var piece = Model.Game.Board.Squares[row][col];
                        var pieceSymbol = "";
                        if (piece != null)
                        {
                            pieceSymbol = GetPieceSymbol(piece);
                        }
                        <div class="chess-square @className"
                             data-row="@row" data-col="@col">
                            @if (!string.IsNullOrEmpty(pieceSymbol))
                            {
                                <div class="chess-piece @(piece.IsWhite ? "white-piece" : "black-piece")"
                                     data-piece="@pieceSymbol" data-row="@row" data-col="@col"
                                     data-piece-type="@piece.GetType().Name"
                                     data-piece-color="@(piece.IsWhite ? "white" : "black")">
                                    @pieceSymbol
                                </div>
                            }
                        </div>
                    }
                }
            </div>
        </div>

        <div class="side-panel">
            <!-- GameMode Indicator -->
            <div class="game-mode-indicator">
                <span>Current Mode:</span>
                <strong>@Model.GameMode<br /></strong>
                @if (Model.GameMode == "PvAI" && !string.IsNullOrEmpty(Model.SelectedAI))
                {
                    <span>AI: <strong>@Model.SelectedAI</strong></span>
                }
            </div>

            <!-- Turn Indicator -->
            <div class="turn-mode-indicator" id="turnIndicator">
                @if (Model.Game.IsGameOver)
                {
                    <span>@Model.GameResult</span>
                }
                else
                {
                    <span><strong>@(Model.IsWhiteTurn ? "White's" : "Black's")</strong> turn.</span>
                    @if (Model.IsWhiteKingInCheck)
                    {
                        <div class="check-indicator">White check!</div>
                    }
                    @if (Model.IsBlackKingInCheck)
                    {
                        <div class="check-indicator">Black check!</div>
                    }
                }
            </div>

            <!-- AI Selection UI (only visible in PvAI mode) -->
            @if (Model.GameMode == "PvAI")
            {
                <div class="ai-selection-container">
                    <label for="aiSelect">Choose AI:</label>
                    <select id="aiSelect" name="aiSelect">
                        <option value="">-- Select an AI --</option>
                        @foreach (var ai in AIFactory.GetAllAIPlayers())
                        {
                            <option value="@ai.Name">@ai.Name</option>
                        }
                    </select>
                    <button type="button" class="ai-button" onclick="selectAIAndStartGame()">Start Game</button>

                    <div class="resign-button-container">
                        <button type="button" class="ai-button" onclick="resignGame()">Resign</button>
                    </div>
                </div>
            }

            <!-- Local PvP UI (only visible in LocalPvP mode) -->
            @if (Model.GameMode == "LocalPvP")
            {
                <div class="ai-selection-container">
                    <div class="resign-button-container">
                        <button type="button" class="ai-button" onclick="resignGame()">Resign</button>
                    </div>
                    <button type="button" class="ai-button" onclick="setGameMode('LocalPvP')">Restart</button>
                </div>
            }

            <!-- Lobby creation and joining (Visible when in Online PvP mode) -->
            @if (Model.GameMode == "OnlinePvP")
            {
                <div class="ai-selection-container lobby-container">
                    <button type="button" id="createLobbyButton" class="ai-button" onclick="createLobby()">Create Lobby</button>
                    <input type="text" id="joinLobbyCode" placeholder="Enter Lobby Code">
                    <button type="button" id="joinLobbyButton" class="ai-button" onclick="joinLobby()">Join Lobby</button>

                    <!-- Resign button container initially hidden -->
                    <div class="resign-button-container" id="resignButtonContainer" style="display: none;">
                        <button type="button" class="ai-button" onclick="resignGame()">Resign</button>
                    </div>
                </div>

                <!-- Display the lobby code -->
                <div id="lobbyCodeDisplay" class="lobby-code-display" style="display: none;">
                    <span>Your Lobby Code:</span>
                    <strong id="lobbyCodeText"></strong>
                </div>
            }

            <!-- Game Mode Buttons -->
            <div class="gamemode-button-container">
                <button type="button" class="gamemode-button @(Model.GameMode == "OnlinePvP" ? "active" : "")" name="Online PvP" onclick="setGameMode('OnlinePvP')">Online PvP</button>
                <button type="button" class="gamemode-button @(Model.GameMode == "LocalPvP" ? "active" : "")" name="Local PvP" onclick="setGameMode('LocalPvP')">Local PvP</button>
                <button type="button" class="gamemode-button @(Model.GameMode == "PvAI" ? "active" : "")" name="PvAI" onclick="setGameMode('PvAI')">PvAI</button>
            </div>
        </div>
    </div>
    <script>
        (async function () {
            let selectedPiece = null;
            let offsetX = 0, offsetY = 0;
            let originalSquare = null;
            let isGameBusy = false;
            const requestVerificationToken = document.getElementById('RequestVerificationToken').value;
            const turnIndicator = document.getElementById('turnIndicator');
            const gameResultModal = document.getElementById('gameResultModal');
            const gameResultMessage = document.getElementById('gameResultMessage');

            let isGameOver = @Html.Raw(Json.Serialize(Model.Game.IsGameOver));
            let isWhiteTurn = @Html.Raw(Json.Serialize(Model.Game.IsWhiteTurn));
            let isBoardFlipped = false; // Flag to indicate if the board is flipped (for black player)

            const sounds = {
                Move: new Audio('/sounds/move.mp3'), //https://freesound.org/people/alegemaate/sounds/364691/
                Capture: new Audio('/sounds/capture.mp3'), // https://freesound.org/people/SamsterBirdies/sounds/745291/
                Castle: new Audio('/sounds/castle.mp3'),//https://freesound.org/people/theshaggyfreak/sounds/274939/
                Promotion: new Audio('/sounds/promotion.mp3'), //https://freesound.org/people/Geoff-Bremner-Audio/sounds/670316/
                Check: new Audio('/sounds/check.mp3'), //https://freesound.org/people/hollandm/sounds/692822/
                Stalemate: new Audio('/sounds/stalemate.mp3'),//https://freesound.org/people/CogFireStudios/sounds/531508/
                Victory: new Audio('/sounds/victory.mp3'),//https://freesound.org/people/mickleness/sounds/269198/
                Defeat: new Audio('/sounds/defeat.mp3'), //https://freesound.org/people/kanaizo/sounds/731657/

            };

            // Preload sounds
            for (const sound in sounds) {
                sounds[sound].preload = 'auto';
            }

            function playSound(event) {
                const sound = sounds[event];
                if (sound) {
                    sound.currentTime = 0;
                    sound.play().catch(error => {
                        console.error(`Failed to play sound: ${event}`, error);
                    });
                } else {
                    console.warn(`Sound not found: ${event}`);
                }
            }

            // Close the modal
            function closeGameResultModal() {
                gameResultModal.style.display = 'none';
            }

            window.closeGameResultModal = closeGameResultModal;

            // Allow closing the modal by clicking outside
            gameResultModal.addEventListener('click', function (event) {
                if (event.target === gameResultModal) {
                    closeGameResultModal();
                }
            });

            // Event Delegation for pointer events
            const chessBoard = document.getElementById('chessBoard');
            chessBoard.addEventListener('pointerdown', handlePointerDown);

            function handlePointerDown(event) {
                if (!event.target.classList.contains('chess-piece')) return;

                if (isGameOver || isGameBusy) {
                    // Prevent moving pieces if the game is over or if AI is busy
                    return;
                }

                // In Online PvP mode, check if it's the player's turn
                if (gameMode === 'OnlinePvP' && ((isWhiteTurn && playerColor !== 'white') || (!isWhiteTurn && playerColor !== 'black'))) {
                    // Not this player's turn
                    return;
                }

                const pieceColor = event.target.dataset.pieceColor;

                if ((isWhiteTurn && pieceColor !== 'white') || (!isWhiteTurn && pieceColor !== 'black')) {
                    // Not this player's turn
                    return;
                }

                selectedPiece = event.target;
                originalSquare = selectedPiece.parentElement;

                // Get the touch/mouse position relative to the piece
                const rect = selectedPiece.getBoundingClientRect();
                offsetX = event.clientX - rect.left;
                offsetY = event.clientY - rect.top;

                selectedPiece.style.zIndex = 1000;
                selectedPiece.setPointerCapture(event.pointerId);

                // Ensure the piece retains the flipped class if the board is flipped
                if (isBoardFlipped) {
                    selectedPiece.classList.add('flipped-piece');
                } else {
                    selectedPiece.classList.remove('flipped-piece');
                }

                // Highlight possible moves
                const fromRow = parseInt(selectedPiece.dataset.row, 10);
                const fromCol = parseInt(selectedPiece.dataset.col, 10);
                getValidMoves(fromRow, fromCol);

                // Add event listeners with throttling
                document.addEventListener('pointermove', throttledPointerMove);
                document.addEventListener('pointerup', handlePointerUp);

                event.preventDefault();
            }

            const throttledPointerMove = throttle((event) => {
                if (selectedPiece) {
                    moveAt(event.clientX, event.clientY);
                    event.preventDefault();
                }
            }, 16); // ~60fps

            function handlePointerUp(event) {
                if (selectedPiece) {
                    const square = getSquareUnderPointer(event.clientX, event.clientY);

                    if (square && square.classList.contains('highlight')) {
                        const fromRow = parseInt(selectedPiece.dataset.row, 10);
                        const fromCol = parseInt(selectedPiece.dataset.col, 10);
                        const toRow = parseInt(square.dataset.row, 10);
                        const toCol = parseInt(square.dataset.col, 10);
                        postMove(fromRow, fromCol, toRow, toCol);
                    } else {
                        resetPiecePosition(selectedPiece);
                    }

                    clearHighlights();
                    document.removeEventListener('pointermove', throttledPointerMove);
                    document.removeEventListener('pointerup', handlePointerUp);
                    selectedPiece = null;
                    originalSquare = null;

                    event.preventDefault();
                }
            }

            function moveAt(clientX, clientY) {
                const parentRect = originalSquare.getBoundingClientRect();
                let x, y;

                // Calculate x and y based on whether the board is flipped
                if (isBoardFlipped) {
                    // Adjust for normal movement but apply rotation only visually
                    x = clientX - parentRect.left - offsetX;
                    y = clientY - parentRect.top - offsetY;
                } else {
                    // Normal movement if the board is not flipped
                    x = clientX - parentRect.left - offsetX;
                    y = clientY - parentRect.top - offsetY;
                }

                // Apply visual rotation without changing coordinates for flipped board
                const rotation = isBoardFlipped ? 'rotate(180deg)' : '';
                selectedPiece.style.transform = `${rotation} translate3d(${x}px, ${y}px, 0)`;
            }

            function getSquareUnderPointer(x, y) {
                const elements = document.elementsFromPoint(x, y);
                return elements.find(el => el.classList.contains('chess-square'));
            }

            function resetPiecePosition(piece) {
                piece.style.transform = '';
                piece.style.zIndex = '';
                // Remove the flipped-piece class after dropping
                piece.classList.remove('flipped-piece');
            }

            document.addEventListener('click', function (event) {
                if (event.target.classList.contains('chess-square')) {
                    squareClick(event);
                }
            });

            function squareClick(event) {
                if (!selectedPiece) return;

                const targetSquare = event.target;
                if (!targetSquare.classList.contains('highlight')) return;

                const fromRow = parseInt(selectedPiece.dataset.row, 10);
                const fromCol = parseInt(selectedPiece.dataset.col, 10);
                const toRow = parseInt(targetSquare.dataset.row, 10);
                const toCol = parseInt(targetSquare.dataset.col, 10);

                postMove(fromRow, fromCol, toRow, toCol);
                clearHighlights();
                selectedPiece = null;
                originalSquare = null;
            }

            function getValidMoves(row, col) {
                if (gameMode === 'OnlinePvP') {
                    connection.invoke('GetValidMoves', lobbyCode, row, col);
                } else {
                    fetch('/Home/GetValidMoves', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': requestVerificationToken
                        },
                        body: JSON.stringify({ row, col })
                    })
                        .then(response => {
                            if (response.ok) return response.json();
                            throw new Error('Failed to fetch valid moves.');
                        })
                        .then(validMoves => highlightValidMoves(validMoves))
                        .catch(error => console.error('Error:', error));
                }
            }

            function highlightValidMoves(moves) {
                moves.forEach(move => {
                    const row = move.row;
                    const col = move.col;
                    const square = document.querySelector(`.chess-square[data-row='${row}'][data-col='${col}']`);
                    if (square) {
                        square.classList.add('highlight');
                    }
                });
            }

            function clearHighlights() {
                const highlightedSquares = document.querySelectorAll('.chess-square.highlight');
                highlightedSquares.forEach(square => {
                    square.classList.remove('highlight');
                });
            }

            // Resign Button Handling
            async function resignGame() {
                if (isGameBusy || isGameOver) return;
                const confirmation = confirm("Are you sure you want to resign?");
                if (!confirmation) return;

                isGameBusy = true;

                try {
                    if (gameMode === 'OnlinePvP') {
                        await connection.invoke('ResignGame', lobbyCode);
                        // The game will end when we receive 'GameOver' from the hub
                    } else {
                        const response = await fetch('/Home/ResignGame', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'RequestVerificationToken': requestVerificationToken
                            }
                        });

                        if (!response.ok) throw new Error('Failed to resign the game.');

                        const data = await response.json();

                        if (data.isGameOver) {
                            handleGameOver(data.gameResult);
                        }

                        isGameBusy = false;
                    }
                } catch (error) {
                    console.error('Error:', error);
                    alert('An error occurred while resigning the game.');
                    isGameBusy = false;
                }
            }

            window.resignGame = resignGame;

            function handleGameOver(gameResult) {
                if (gameResult.includes("wins")) {
                    playSound(gameResult.includes("resignation") ? 'Victory' : 'Checkmate');
                } else if (gameResult.includes("draw") || gameResult.includes("stalemate")) {
                    playSound('Stalemate');
                } else {
                    playSound('Defeat');
                }

                showGameResultModal(gameResult);
                updateTurnIndicator(null, null, null, true, gameResult);

                isGameOver = true;

                // Hide the resign button as the game is over
                const resignButtonContainer = document.getElementById('resignButtonContainer');
                if (resignButtonContainer) {
                    resignButtonContainer.style.display = 'none';
                }
            }

            function updateTurnIndicator(isWhiteTurnParam, isWhiteKingInCheck, isBlackKingInCheck, isGameOverParam, message) {
                if (isGameOverParam) {
                    turnIndicator.innerHTML = `<span>${message}</span>`;
                    return;
                }

                // Only display the message if it's not null or empty
                if (message && message.trim() !== "") {
                    turnIndicator.innerHTML = `<span>${message}</span>`;
                    return;
                }

                // Display whose turn it is
                let html = `<span><strong>${isWhiteTurnParam ? "White's" : "Black's"}</strong> turn.</span>`;
                if (isWhiteKingInCheck) {
                    html += '<div class="check-indicator">White check!</div>';
                }
                if (isBlackKingInCheck) {
                    html += '<div class="check-indicator">Black check!</div>';
                }
                turnIndicator.innerHTML = html;
            }

            // Game Mode Variable
            let gameMode = '@Model.GameMode';

            // Player color and lobby code for Online PvP
            let playerColor = null;
            let lobbyCode = null;

            // SignalR connection
            let connection = null;

            if (gameMode === 'OnlinePvP') {
                // Establish SignalR connection
                connection = new signalR.HubConnectionBuilder()
                    .withUrl('/chessHub')
                    .build();

                await connection.start();

                // Handle messages from the hub
                connection.on('LobbyCreated', function (code) {
                    // Display the lobby code in the sidebar
                    lobbyCode = code;
                    playerColor = 'white';
                    isWhiteTurn = true;

                    // Update UI to indicate waiting for opponent
                    document.getElementById('createLobbyButton').disabled = true;
                    document.getElementById('joinLobbyButton').disabled = true;
                    document.getElementById('joinLobbyCode').disabled = true;
                    document.getElementById('turnIndicator').innerHTML = '<span>Waiting for opponent to join...</span>';

                    // Show the lobby code display
                    const lobbyCodeDisplay = document.getElementById('lobbyCodeDisplay');
                    const lobbyCodeText = document.getElementById('lobbyCodeText');
                    lobbyCodeText.textContent = code;
                    lobbyCodeDisplay.style.display = 'block';
                });

                connection.on('LobbyCreationFailed', function (message) {
                    alert('Failed to create lobby: ' + message);
                });

                connection.on('StartGame', function (code) {
                    // Display the lobby code for the player who joined
                    if (playerColor === 'black') {
                        const lobbyCodeDisplay = document.getElementById('lobbyCodeDisplay');
                        const lobbyCodeText = document.getElementById('lobbyCodeText');
                        lobbyCodeText.textContent = code;
                        lobbyCodeDisplay.style.display = 'block';
                    }

                    // Show the resign button as the game has started
                    const resignButtonContainer = document.getElementById('resignButtonContainer');
                    if (resignButtonContainer) {
                        resignButtonContainer.style.display = 'block';
                    }

                    if (playerColor === 'white') {
                        document.getElementById('turnIndicator').innerHTML = '<span>Your turn.</span>';
                    } else {
                        document.getElementById('turnIndicator').innerHTML = '<span>Opponent\'s turn.</span>';
                        // Flip the board for black player
                        flipBoard();
                    }
                });

                connection.on('LobbyJoinFailed', function (message) {
                    alert('Failed to join lobby: ' + message);
                });

                connection.on('ReceiveMove', function (moveDetails) {
                    const { fromRow, fromCol, toRow, toCol } = moveDetails;
                    movePieceInUI(fromRow, fromCol, toRow, toCol, moveDetails);

                    // Correctly update isWhiteTurn using camelCase
                    isWhiteTurn = moveDetails.isWhiteTurn;
                    console.log(`Move received. Next turn: ${isWhiteTurn ? "White" : "Black"}`);

                    // Pass gameResult only if the game is over
                    const message = moveDetails.isGameOver ? moveDetails.gameResult : null;

                    updateTurnIndicator(
                        moveDetails.isWhiteTurn,
                        moveDetails.isWhiteKingInCheck,
                        moveDetails.isBlackKingInCheck,
                        moveDetails.isGameOver,
                        message
                    );

                    // Play appropriate sounds based on move details
                    if (moveDetails.isCheckmate) {
                        playSound('Checkmate');
                    } else if (moveDetails.isCheck) {
                        playSound('Check');
                    } else if (moveDetails.isCastle) {
                        playSound('Castle');
                    } else if (moveDetails.isCapture || moveDetails.isEnPassantCapture) {
                        playSound('Capture');
                    } else if (moveDetails.isPromotion) {
                        playSound('Promotion');
                    } else {
                        playSound('Move');
                    }

                    if (moveDetails.isGameOver) {
                        handleGameOver(moveDetails.gameResult);
                    }
                });

                connection.on('InvalidMove', function (message) {
                    alert('Invalid move: ' + message);
                    if (selectedPiece) resetPiecePosition(selectedPiece);
                    isGameBusy = false;
                });

                connection.on('ReceiveValidMoves', function (validMoves) {
                    highlightValidMoves(validMoves);
                });

                connection.on('GameOver', function (gameResult) {
                    handleGameOver(gameResult);
                    // Hide the resign button as the game is over
                    const resignButtonContainer = document.getElementById('resignButtonContainer');
                    if (resignButtonContainer) {
                        resignButtonContainer.style.display = 'none';
                    }
                });

                connection.on('OpponentDisconnected', function (message) {

                    // Check if the game is already over
                    if (!isGameOver) {
                        alert(message);
                        handleGameOver("Opponent has disconnected. You win!");
                    }
                    // Else, do nothing or notify that the game has already concluded.
                });

                // Function to create lobby
                window.createLobby = function () {
                    connection.invoke('CreateLobby');
                };

                // Function to join lobby
                window.joinLobby = function () {
                    const code = document.getElementById('joinLobbyCode').value.trim().toUpperCase();
                    if (!code) {
                        alert('Please enter a lobby code.');
                        return;
                    }
                    connection.invoke('JoinLobby', code)
                        .then(function () {
                            lobbyCode = code;
                            playerColor = 'black';
                            isWhiteTurn = true;

                            // Flip the board for black player
                            flipBoard();

                            // Update UI
                            document.getElementById('createLobbyButton').disabled = true;
                            document.getElementById('joinLobbyButton').disabled = true;
                            document.getElementById('joinLobbyCode').disabled = true;
                            document.getElementById('turnIndicator').innerHTML = '<span>Opponent\'s turn.</span>';
                        })
                        .catch(function (err) {
                            alert('Failed to join lobby: ' + err.toString());
                        });
                };

                function flipBoard() {
                    const chessBoard = document.getElementById('chessBoard');
                    chessBoard.classList.add('flipped');
                    isBoardFlipped = true;

                    // Add flipped-piece class to all pieces
                    document.querySelectorAll('.chess-piece').forEach(piece => {
                        piece.classList.add('flipped-piece');
                    });

                    // Update turn indicator if necessary
                    if (playerColor === 'black') {
                        document.getElementById('turnIndicator').innerHTML = '<span>Black\'s turn.</span>';
                    }
                }

                // Expose functions to global scope
                window.flipBoard = flipBoard;
            }

            async function postMove(fromRow, fromCol, toRow, toCol) {
                // In Online PvP mode, check if it's the player's turn
                if (gameMode === 'OnlinePvP' && ((isWhiteTurn && playerColor !== 'white') || (!isWhiteTurn && playerColor !== 'black'))) {
                    alert('It is not your turn.');
                    if (selectedPiece) resetPiecePosition(selectedPiece);
                    return;
                }

                if (isGameBusy) return;
                isGameBusy = true;

                try {
                    if (gameMode === 'OnlinePvP') {
                        // Send the move to the hub
                        await connection.invoke('SendMove', lobbyCode, { FromRow: fromRow, FromCol: fromCol, ToRow: toRow, ToCol: toCol });

                        // The move will be applied when we receive "ReceiveMove"" from the hub
                        isGameBusy = false;
                    } else {
                        // Local PvP or PvAI mode
                        const response = await fetch('/Home/MakeMove', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'RequestVerificationToken': requestVerificationToken
                            },
                            body: JSON.stringify({ FromRow: fromRow, FromCol: fromCol, ToRow: toRow, ToCol: toCol })
                        });

                        if (!response.ok) throw new Error('Invalid move.');

                        const data = await response.json();

                        if (data.success) {
                            movePieceInUI(fromRow, fromCol, toRow, toCol, data);
                            playPlayerMoveSound(data);

                            if (data.aiMove) {
                                updateTurnIndicator(null, null, null, false, "AI is thinking...");
                                setTimeout(() => {
                                    makeAIMove(data.aiMove.from, data.aiMove.to, data);
                                    updateTurnIndicator(data.isWhiteTurn, data.isWhiteKingInCheck, data.isBlackKingInCheck, data.isGameOver, data.isGameOver ? data.gameResult : null);
                                    isWhiteTurn = data.isWhiteTurn; // Update the turn

                                    if (data.isGameOver) {
                                        handleGameOver(data.gameResult);
                                    }

                                    isGameBusy = false;
                                }, 1000); // Delay before AI moves
                            } else {
                                updateTurnIndicator(data.isWhiteTurn, data.isWhiteKingInCheck, data.isBlackKingInCheck, data.isGameOver, data.isGameOver ? data.gameResult : null);
                                isWhiteTurn = data.isWhiteTurn; // Update the turn

                                if (data.isGameOver) {
                                    handleGameOver(data.gameResult);
                                }

                                isGameBusy = false;
                            }
                        } else {
                            alert('Invalid move.');
                            resetPiecePosition(selectedPiece);
                            isGameBusy = false;
                        }
                    }
                } catch (error) {
                    console.error('Error:', error);
                    alert('An error occurred while making the move.');
                    if (selectedPiece) resetPiecePosition(selectedPiece);
                    isGameBusy = false;
                }
            }

            function movePieceInUI(fromRow, fromCol, toRow, toCol, data) {
                const fromSquare = document.querySelector(`.chess-square[data-row='${fromRow}'][data-col='${fromCol}']`);
                const toSquare = document.querySelector(`.chess-square[data-row='${toRow}'][data-col='${toCol}']`);

                if (fromSquare && toSquare) {
                    const piece = fromSquare.querySelector('.chess-piece');
                    if (piece) {
                        const capturedPiece = toSquare.querySelector('.chess-piece');
                        if (capturedPiece) capturedPiece.remove();

                        toSquare.appendChild(piece);
                        piece.dataset.row = toRow;
                        piece.dataset.col = toCol;
                        resetPiecePosition(piece);

                        // Handle special moves
                        if (data && (data.playerIsPromotion || data.isPromotion)) {
                            promotePawn(piece);
                        }
                        if (data && (data.playerIsEnPassantCapture || data.isEnPassantCapture)) {
                            captureEnPassant(piece, toRow, toCol);
                        }
                        if (data && (data.playerIsCastle || data.isCastle)) {
                            castleRook(piece, fromRow, fromCol, toCol);
                        }
                    }
                }
            }

            function promotePawn(piece) {
                const isWhite = piece.dataset.pieceColor === 'white';
                const queenSymbol = isWhite ? '♕' : '♛';
                piece.textContent = queenSymbol;
                piece.dataset.pieceType = 'Queen';
                piece.dataset.piece = queenSymbol;
                playSound('Promotion');
            }

            function captureEnPassant(piece, toRow, toCol) {
                const direction = piece.dataset.pieceColor === 'white' ? 1 : -1;
                const capturedPawnRow = toRow + direction;
                const capturedPawnSquare = document.querySelector(`.chess-square[data-row='${capturedPawnRow}'][data-col='${toCol}']`);
                const capturedPawn = capturedPawnSquare.querySelector('.chess-piece');
                if (capturedPawn) capturedPawn.remove();
                playSound('Capture');
            }

            function castleRook(piece, fromRow, fromCol, toCol) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? toCol - 1 : toCol + 1;
                const rookRow = fromRow;
                const rookFromSquare = document.querySelector(`.chess-square[data-row='${rookRow}'][data-col='${rookFromCol}']`);
                const rookToSquare = document.querySelector(`.chess-square[data-row='${rookRow}'][data-col='${rookToCol}']`);
                const rookPiece = rookFromSquare.querySelector('.chess-piece');
                if (rookPiece) {
                    rookToSquare.appendChild(rookPiece);
                    rookPiece.dataset.row = rookRow;
                    rookPiece.dataset.col = rookToCol;
                    resetPiecePosition(rookPiece);
                    playSound('Castle');
                }
            }

            function playPlayerMoveSound(data) {
                if (data.playerIsCheckmate) {
                    playSound('Checkmate');
                } else if (data.playerIsCheck) {
                    playSound('Check');
                } else if (data.playerIsCastle) {
                    playSound('Castle');
                } else if (data.playerIsCapture || data.playerIsEnPassantCapture) {
                    playSound('Capture');
                } else if (data.playerIsPromotion) {

                } else {
                    playSound('Move');
                }
            }

            function playAIMoveSound(data) {
                if (data.aiIsCheckmate) {
                    playSound('Checkmate');
                } else if (data.aiIsCheck) {
                    playSound('Check');
                } else if (data.aiIsCastle) {
                    playSound('Castle');
                } else if (data.aiIsCapture || data.aiIsEnPassantCapture) {
                    playSound('Capture');
                } else if (data.aiIsPromotion) {

                } else {
                    playSound('Move');
                }
            }

            function makeAIMove(from, to, data) {
                const fromRow = from.row ?? from.Row;
                const fromCol = from.col ?? from.Col;
                const toRow = to.row ?? to.Row;
                const toCol = to.col ?? to.Col;

                const fromSquare = document.querySelector(`.chess-square[data-row='${fromRow}'][data-col='${fromCol}']`);
                const toSquare = document.querySelector(`.chess-square[data-row='${toRow}'][data-col='${toCol}']`);

                if (fromSquare && toSquare) {
                    const piece = fromSquare.querySelector('.chess-piece');
                    if (piece) {
                        const capturedPiece = toSquare.querySelector('.chess-piece');
                        if (capturedPiece) capturedPiece.remove();

                        toSquare.appendChild(piece);
                        piece.dataset.row = toRow;
                        piece.dataset.col = toCol;
                        resetPiecePosition(piece);

                        // Handle special moves
                        if (data.aiIsPromotion) {
                            promotePawn(piece);
                        }
                        if (data.aiIsEnPassantCapture) {
                            captureEnPassant(piece, toRow, toCol);
                        }
                        if (data.aiIsCastle) {
                            castleRook(piece, fromRow, fromCol, toCol);
                        }

                        playAIMoveSound(data);

                        // Update the turn
                        isWhiteTurn = data.isWhiteTurn;

                        // Handle game over if the game ends after AI's move
                        if (data.isGameOver) {
                            handleGameOver(data.gameResult);
                        }
                    }
                }
            }

            function showGameResultModal(message) {
                gameResultMessage.textContent = message;
                gameResultModal.style.display = 'flex';
            }

            function restartGame() {
                const restartButton = document.querySelector('.restart-button');
                if (restartButton) {
                    restartButton.disabled = true;
                    restartButton.textContent = 'Restarting...';
                }

                fetch('/Home/RestartGame', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': requestVerificationToken
                    }
                })
                    .then(response => {
                        if (response.ok) {
                            window.location.reload();
                        } else {
                            throw new Error('Failed to restart the game.');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred while restarting the game.');
                        if (restartButton) {
                            restartButton.disabled = false;
                            restartButton.textContent = 'Rematch';
                        }
                    });
            }

            function selectAIAndStartGame() {
                const aiSelect = document.getElementById('aiSelect');
                const aiName = aiSelect ? aiSelect.value : null;
                if (!aiName) {
                    alert('Please select an AI to start the game.');
                    return;
                }

                fetch('/Home/SelectAI', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': requestVerificationToken
                    },
                    body: JSON.stringify({ AIName: aiName })
                })
                    .then(response => {
                        if (response.ok) {
                            window.location.reload();
                        } else {
                            throw new Error('Failed to select AI.');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred while selecting the AI.');
                    });
            }

            function setGameMode(mode) {
                fetch('/Home/SetGameMode', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': requestVerificationToken
                    },
                    body: JSON.stringify({ GameMode: mode })
                })
                    .then(response => {
                        if (response.ok) {
                            window.location.reload();
                        } else {
                            throw new Error('Failed to set game mode.');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred while setting the game mode.');
                    });
            }

            // Throttle function to limit the rate at which a function can fire
            function throttle(fn, limit) {
                let lastFunc;
                let lastRan;
                return function (...args) {
                    const context = this;
                    if (!lastRan) {
                        fn.apply(context, args);
                        lastRan = Date.now();
                    } else {
                        clearTimeout(lastFunc);
                        lastFunc = setTimeout(function () {
                            if ((Date.now() - lastRan) >= limit) {
                                fn.apply(context, args);
                                lastRan = Date.now();
                            }
                        }, limit - (Date.now() - lastRan));
                    }
                }
            }

            // Expose functions to global scope
            window.restartGame = restartGame;
            window.selectAIAndStartGame = selectAIAndStartGame;
            window.setGameMode = setGameMode;

        })();
    </script>

    @functions {
        private string GetPieceSymbol(Piece piece)
        {
            if (piece is Pawn)
                return piece.IsWhite ? "♙" : "♟";
            else if (piece is Rook)
                return piece.IsWhite ? "♖" : "♜";
            else if (piece is Knight)
                return piece.IsWhite ? "♘" : "♞";
            else if (piece is Bishop)
                return piece.IsWhite ? "♗" : "♝";
            else if (piece is Queen)
                return piece.IsWhite ? "♕" : "♛";
            else if (piece is King)
                return piece.IsWhite ? "♔" : "♚";
            else
                return "";
        }
    }

</body>
</html>