@model ChessAI.Controllers.HomeController.PlayViewModel
@using ChessAI.Models.AIs
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Antiforgery

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="~/css/site.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <input type="hidden" id="RequestVerificationToken" value="@Antiforgery.GetAndStoreTokens(ViewContext.HttpContext).RequestToken" />

    <div class="main-container">
        <div class="chess-board-container">
            <!-- GameResult Modal -->
            <div id="gameResultModal" class="game-result-modal" style="display: none;">
                <div class="game-result-content">
                    <span id="gameResultMessage" class="game-result-message"></span>
                    <div class="modal-buttons">
                        <button type="button" class="restart-button" onclick="restartGame()">Restart</button>
                        <button type="button" class="close-button" onclick="closeGameResultModal()">Close</button>
                    </div>
                </div>
            </div>

            <div class="chess-board @(Model.GameMode == "PvAI" && string.IsNullOrEmpty(ViewBag.SelectedAI) ? "disabled" : "")" id="chessBoard">
                @for (int row = 0; row < 8; row++)
                {
                    @for (int col = 0; col < 8; col++)
                    {
                        var isBlack = (row + col) % 2 == 0;
                        var className = isBlack ? "black" : "white";
                        var piece = Model.Game.Board.Squares[row][col];
                        var pieceSymbol = "";
                        if (piece != null)
                        {
                            pieceSymbol = GetPieceSymbol(piece);
                        }
                        <div class="chess-square @className"
                             data-row="@row" data-col="@col">
                            @if (!string.IsNullOrEmpty(pieceSymbol))
                            {
                                <div class="chess-piece @(piece.IsWhite ? "white-piece" : "black-piece")"
                                     data-piece="@pieceSymbol" data-row="@row" data-col="@col"
                                     data-piece-type="@piece.GetType().Name"
                                     data-piece-color="@(piece.IsWhite ? "white" : "black")">
                                    @pieceSymbol
                                </div>
                            }
                        </div>
                    }
                }
            </div>
        </div>

        <div class="side-panel">
            <!-- GameMode Indicator -->
            <div class="game-mode-indicator">
                <span>Current Mode:</span>
                <strong>@Model.GameMode<br /></strong>
                @if (Model.GameMode == "PvAI" && !string.IsNullOrEmpty(Model.SelectedAI))
                {
                    <span>AI: <strong>@Model.SelectedAI</strong></span>
                }
            </div>

            <!-- Turn Indicator -->
            <div class="turn-mode-indicator" id="turnIndicator">
                @if (Model.Game.IsGameOver)
                {
                    <span>Game Over</span>
                }
                else
                {
                    <span>It's <strong>@(Model.IsWhiteTurn ? "White's" : "Black's")</strong> turn.</span>
                    @if (Model.IsWhiteKingInCheck)
                    {
                        <div class="check-indicator">White king is in check!</div>
                    }
                    @if (Model.IsBlackKingInCheck)
                    {
                        <div class="check-indicator">Black king is in check!</div>
                    }
                }
            </div>

            <!-- AI Selection UI (only visible in PvAI mode) -->
            @if (Model.GameMode == "PvAI")
            {
                <div class="ai-selection-container">
                    <label for="aiSelect">Choose AI:</label>
                    <select id="aiSelect" name="aiSelect">
                        <option value="">-- Select an AI --</option>
                        @foreach (var ai in AIFactory.GetAllAIPlayers())
                        {
                            <option value="@ai.Name">@ai.Name</option>
                        }
                    </select>
                    <button type="button" class="ai-button" onclick="selectAIAndStartGame()">Start Game</button>
                    <button type="button" class="ai-button" onclick="setGameMode('PvAI')">Restart</button>
                </div>
            }

            <!-- PvP Selection UI (only visible in PvP mode) -->
            @if (Model.GameMode == "LocalPvP")
            {
                <div class="ai-selection-container">
                    <button type="button" class="ai-button" onclick="setGameMode('LocalPvP')">Restart</button>
                </div>
            }

            <div class="gamemode-button-container">
                <button type="button" class="gamemode-button @(Model.GameMode == "Tutorial" ? "active" : "")" name="Tutorial" onclick="setGameMode('Tutorial')">Tutorial</button>
                <button type="button" class="gamemode-button @(Model.GameMode == "LocalPvP" ? "active" : "")" name="Local PvP" onclick="setGameMode('LocalPvP')">Local PvP</button>
                <button type="button" class="gamemode-button @(Model.GameMode == "PvAI" ? "active" : "")" name="PvAI" onclick="setGameMode('PvAI')">PvAI</button>
            </div>
        </div>
    </div>
    <script>
        (function () {
            let selectedPiece = null;
            let offsetX = 0, offsetY = 0;
            let originalSquare = null;
            let isGameBusy = false;
            const requestVerificationToken = document.getElementById('RequestVerificationToken').value;
            const turnIndicator = document.getElementById('turnIndicator');
            const gameResultModal = document.getElementById('gameResultModal');
            const gameResultMessage = document.getElementById('gameResultMessage');

            const isGameOver = @Html.Raw(Json.Serialize(Model.Game.IsGameOver));
            let isWhiteTurn = @Html.Raw(Json.Serialize(Model.Game.IsWhiteTurn));

            const sounds = {
                Move: new Audio('/sounds/move.mp3'),
                Capture: new Audio('/sounds/capture.mp3'),
                Castle: new Audio('/sounds/castle.mp3'),
                Promotion: new Audio('/sounds/promotion.mp3'),
                Check: new Audio('/sounds/check.mp3'),
                Checkmate: new Audio('/sounds/checkmate.mp3'),
                Stalemate: new Audio('/sounds/stalemate.mp3'),
                Victory: new Audio('/sounds/victory.mp3'),
                Defeat: new Audio('/sounds/defeat.mp3'),
                AIThinking: new Audio('/sounds/ai-thinking.mp3')
            };

            // Preload sounds
            for (const sound in sounds) {
                sounds[sound].preload = 'auto';
            }

            function playSound(event) {
                const sound = sounds[event];
                if (sound) {
                    sound.currentTime = 0;
                    sound.play().catch(error => {
                        console.error(`Failed to play sound: ${event}`, error);
                    });
                } else {
                    console.warn(`Sound not found: ${event}`);
                }
            }

            // Close the modal
            function closeGameResultModal() {
                gameResultModal.style.display = 'none';
            }

            window.closeGameResultModal = closeGameResultModal;

            // Allow closing the modal by clicking outside
            gameResultModal.addEventListener('click', function (event) {
                if (event.target === gameResultModal) {
                    closeGameResultModal();
                }
            });

            // Event Delegation for pointer events
            const chessBoard = document.getElementById('chessBoard');
            chessBoard.addEventListener('pointerdown', handlePointerDown);

            function handlePointerDown(event) {
                if (!event.target.classList.contains('chess-piece')) return;

                if (isGameOver || isGameBusy) {
                    // Prevent moving pieces if the game is over or if AI is busy
                    return;
                }

                const pieceColor = event.target.dataset.pieceColor;

                if ((isWhiteTurn && pieceColor !== 'white') || (!isWhiteTurn && pieceColor !== 'black')) {
                    // Not this player's turn
                    return;
                }

                selectedPiece = event.target;
                originalSquare = selectedPiece.parentElement;

                // Get the touch/mouse position relative to the piece
                const rect = selectedPiece.getBoundingClientRect();
                offsetX = event.clientX - rect.left;
                offsetY = event.clientY - rect.top;

                selectedPiece.style.zIndex = 1000;
                selectedPiece.setPointerCapture(event.pointerId);

                // Highlight possible moves
                const fromRow = parseInt(selectedPiece.dataset.row, 10);
                const fromCol = parseInt(selectedPiece.dataset.col, 10);
                getValidMoves(fromRow, fromCol);

                // Add event listeners with throttling
                document.addEventListener('pointermove', throttledPointerMove);
                document.addEventListener('pointerup', handlePointerUp);

                event.preventDefault();
            }

            const throttledPointerMove = throttle((event) => {
                if (selectedPiece) {
                    moveAt(event.clientX, event.clientY);
                    event.preventDefault();
                }
            }, 16); // ~60fps

            function handlePointerUp(event) {
                if (selectedPiece) {
                    const square = getSquareUnderPointer(event.clientX, event.clientY);

                    if (square && square.classList.contains('highlight')) {
                        const fromRow = parseInt(selectedPiece.dataset.row, 10);
                        const fromCol = parseInt(selectedPiece.dataset.col, 10);
                        const toRow = parseInt(square.dataset.row, 10);
                        const toCol = parseInt(square.dataset.col, 10);
                        postMove(fromRow, fromCol, toRow, toCol);
                    } else {
                        resetPiecePosition(selectedPiece);
                    }

                    clearHighlights();
                    document.removeEventListener('pointermove', throttledPointerMove);
                    document.removeEventListener('pointerup', handlePointerUp);
                    selectedPiece = null;
                    originalSquare = null;

                    event.preventDefault();
                }
            }

            function moveAt(clientX, clientY) {
                const parentRect = originalSquare.getBoundingClientRect();
                const x = clientX - parentRect.left - offsetX;
                const y = clientY - parentRect.top - offsetY;
                selectedPiece.style.transform = `translate3d(${x}px, ${y}px, 0)`;
            }

            function getSquareUnderPointer(x, y) {
                const elements = document.elementsFromPoint(x, y);
                return elements.find(el => el.classList.contains('chess-square'));
            }

            function resetPiecePosition(piece) {
                piece.style.transform = '';
                piece.style.zIndex = '';
            }

            document.addEventListener('click', function (event) {
                if (event.target.classList.contains('chess-square')) {
                    squareClick(event);
                }
            });

            function squareClick(event) {
                if (!selectedPiece) return;

                const targetSquare = event.target;
                if (!targetSquare.classList.contains('highlight')) return;

                const fromRow = parseInt(selectedPiece.dataset.row, 10);
                const fromCol = parseInt(selectedPiece.dataset.col, 10);
                const toRow = parseInt(targetSquare.dataset.row, 10);
                const toCol = parseInt(targetSquare.dataset.col, 10);

                postMove(fromRow, fromCol, toRow, toCol);
                clearHighlights();
                selectedPiece = null;
                originalSquare = null;
            }

            function getValidMoves(row, col) {
                fetch('/Home/GetValidMoves', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': requestVerificationToken
                    },
                    body: JSON.stringify({ row, col })
                })
                    .then(response => {
                        if (response.ok) return response.json();
                        throw new Error('Failed to fetch valid moves.');
                    })
                    .then(validMoves => highlightValidMoves(validMoves))
                    .catch(error => console.error('Error:', error));
            }

            function highlightValidMoves(moves) {
                moves.forEach(move => {
                    const row = move.Row ?? move.row;
                    const col = move.Col ?? move.col;
                    const square = document.querySelector(`.chess-square[data-row='${row}'][data-col='${col}']`);
                    if (square) {
                        square.classList.add('highlight');
                    }
                });
            }

            function clearHighlights() {
                const highlightedSquares = document.querySelectorAll('.chess-square.highlight');
                highlightedSquares.forEach(square => {
                    square.classList.remove('highlight');
                });
            }

            function updateTurnIndicator(isWhiteTurnParam, isWhiteKingInCheck, isBlackKingInCheck, isGameOverParam, message) {
                if (isGameOverParam) {
                    turnIndicator.innerHTML = '<span>Game Over</span>';
                    return;
                }

                if (message) {
                    turnIndicator.innerHTML = `<span>${message}</span>`;
                    return;
                }

                let html = `<span>It's <strong>${isWhiteTurnParam ? "White's" : "Black's"}</strong> turn.</span>`;
                if (isWhiteKingInCheck) {
                    html += '<div class="check-indicator">White king is in check!</div>';
                }
                if (isBlackKingInCheck) {
                    html += '<div class="check-indicator">Black king is in check!</div>';
                }
                turnIndicator.innerHTML = html;
            }

            async function postMove(fromRow, fromCol, toRow, toCol) {
                if (isGameBusy) return;
                isGameBusy = true;

                try {
                    const response = await fetch('/Home/MakeMove', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': requestVerificationToken
                        },
                        body: JSON.stringify({ fromRow, fromCol, toRow, toCol })
                    });

                    if (!response.ok) throw new Error('Invalid move.');

                    const data = await response.json();

                    if (data.success) {
                        movePieceInUI(fromRow, fromCol, toRow, toCol, data);
                        playPlayerMoveSound(data);

                        if (data.isGameOver) {
                            handleGameOver(data.gameResult);
                            isGameBusy = false;
                            return;
                        }

                        if (data.aiMove) {
                            updateTurnIndicator(null, null, null, false, "AI is thinking...");
                            playSound('AIThinking');
                            setTimeout(() => {
                                makeAIMove(data.aiMove.from, data.aiMove.to, data);
                                updateTurnIndicator(data.isWhiteTurn, data.isWhiteKingInCheck, data.isBlackKingInCheck, data.isGameOver);
                                isWhiteTurn = data.isWhiteTurn; // Update the turn
                                isGameBusy = false;
                            }, 1000); // Delay before AI moves
                        } else {
                            updateTurnIndicator(data.isWhiteTurn, data.isWhiteKingInCheck, data.isBlackKingInCheck, data.isGameOver);
                            isWhiteTurn = data.isWhiteTurn; // Update the turn
                            isGameBusy = false;
                        }
                    } else {
                        alert('Invalid move.');
                        resetPiecePosition(selectedPiece);
                        isGameBusy = false;
                    }
                } catch (error) {
                    console.error('Error:', error);
                    alert('An error occurred while making the move.');
                    if (selectedPiece) resetPiecePosition(selectedPiece);
                    isGameBusy = false;
                }
            }

            function movePieceInUI(fromRow, fromCol, toRow, toCol, data) {
                const fromSquare = document.querySelector(`.chess-square[data-row='${fromRow}'][data-col='${fromCol}']`);
                const toSquare = document.querySelector(`.chess-square[data-row='${toRow}'][data-col='${toCol}']`);

                if (fromSquare && toSquare) {
                    const piece = fromSquare.querySelector('.chess-piece');
                    if (piece) {
                        const capturedPiece = toSquare.querySelector('.chess-piece');
                        if (capturedPiece) capturedPiece.remove();

                        toSquare.appendChild(piece);
                        piece.dataset.row = toRow;
                        piece.dataset.col = toCol;
                        resetPiecePosition(piece);

                        // Handle special moves
                        if (data.playerIsPromotion) {
                            promotePawn(piece);
                        }
                        if (data.playerIsEnPassantCapture) {
                            captureEnPassant(piece, toRow, toCol);
                        }
                        if (data.playerIsCastle) {
                            castleRook(piece, fromRow, fromCol, toCol);
                        }
                    }
                }
            }

            function promotePawn(piece) {
                const isWhite = piece.dataset.pieceColor === 'white';
                const queenSymbol = isWhite ? '♕' : '♛';
                piece.textContent = queenSymbol;
                piece.dataset.pieceType = 'Queen';
                piece.dataset.piece = queenSymbol;
                playSound('Promotion');
            }

            function captureEnPassant(piece, toRow, toCol) {
                const direction = piece.dataset.pieceColor === 'white' ? 1 : -1;
                const capturedPawnRow = toRow + direction;
                const capturedPawnSquare = document.querySelector(`.chess-square[data-row='${capturedPawnRow}'][data-col='${toCol}']`);
                const capturedPawn = capturedPawnSquare.querySelector('.chess-piece');
                if (capturedPawn) capturedPawn.remove();
                playSound('Capture');
            }

            function castleRook(piece, fromRow, fromCol, toCol) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? toCol - 1 : toCol + 1;
                const rookRow = fromRow;
                const rookFromSquare = document.querySelector(`.chess-square[data-row='${rookRow}'][data-col='${rookFromCol}']`);
                const rookToSquare = document.querySelector(`.chess-square[data-row='${rookRow}'][data-col='${rookToCol}']`);
                const rookPiece = rookFromSquare.querySelector('.chess-piece');
                if (rookPiece) {
                    rookToSquare.appendChild(rookPiece);
                    rookPiece.dataset.row = rookRow;
                    rookPiece.dataset.col = rookToCol;
                    resetPiecePosition(rookPiece);
                    playSound('Castle');
                }
            }

            function playPlayerMoveSound(data) {
                if (data.playerIsCheckmate) {
                    playSound('Checkmate');
                } else if (data.playerIsCheck) {
                    playSound('Check');
                } else if (data.playerIsCastle) {
                    playSound('Castle');
                } else if (data.playerIsCapture || data.playerIsEnPassantCapture) {
                    playSound('Capture');
                } else if (data.playerIsPromotion) {

                } else {
                    playSound('Move');
                }
            }

            function playAIMoveSound(data) {
                if (data.aiIsCheckmate) {
                    playSound('Checkmate');
                } else if (data.aiIsCheck) {
                    playSound('Check');
                } else if (data.aiIsCastle) {
                    playSound('Castle');
                } else if (data.aiIsCapture || data.aiIsEnPassantCapture) {
                    playSound('Capture');
                } else if (data.aiIsPromotion) {

                } else {
                    playSound('Move');
                }
            }

            function makeAIMove(from, to, data) {
                const fromSquare = document.querySelector(`.chess-square[data-row='${from.row}'][data-col='${from.col}']`);
                const toSquare = document.querySelector(`.chess-square[data-row='${to.row}'][data-col='${to.col}']`);

                if (fromSquare && toSquare) {
                    const piece = fromSquare.querySelector('.chess-piece');
                    if (piece) {
                        const capturedPiece = toSquare.querySelector('.chess-piece');
                        if (capturedPiece) capturedPiece.remove();

                        toSquare.appendChild(piece);
                        piece.dataset.row = to.row;
                        piece.dataset.col = to.col;
                        resetPiecePosition(piece);

                        // Handle special moves
                        if (data.aiIsPromotion) {
                            promotePawn(piece);
                        }
                        if (data.aiIsEnPassantCapture) {
                            captureEnPassant(piece, to.row, to.col);
                        }
                        if (data.aiIsCastle) {
                            castleRook(piece, from.row, from.col, to.col);
                        }

                        playAIMoveSound(data);

                        if (data.isGameOver) {
                            handleGameOver(data.gameResult);
                        }

                        // Update the turn
                        isWhiteTurn = data.isWhiteTurn;
                    }
                }
            }

            function handleGameOver(gameResult) {
                if (gameResult.includes("wins")) {
                    playSound('Victory');
                } else if (gameResult.includes("draw") || gameResult.includes("stalemate")) {
                    playSound('Stalemate');
                } else {
                    playSound('Defeat');
                }

                showGameResultModal(gameResult);
            }

            function showGameResultModal(message) {
                gameResultMessage.textContent = message;
                gameResultModal.style.display = 'flex';
            }

            function restartGame() {
                const restartButton = document.querySelector('.restart-button');
                if (restartButton) {
                    restartButton.disabled = true;
                    restartButton.textContent = 'Restarting...';
                }

                fetch('/Home/RestartGame', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': requestVerificationToken
                    }
                })
                    .then(response => {
                        if (response.ok) {
                            window.location.reload();
                        } else {
                            throw new Error('Failed to restart the game.');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred while restarting the game.');
                        if (restartButton) {
                            restartButton.disabled = false;
                            restartButton.textContent = 'Restart';
                        }
                    });
            }

            function selectAIAndStartGame() {
                const aiSelect = document.getElementById('aiSelect');
                const aiName = aiSelect ? aiSelect.value : null;
                if (!aiName) {
                    alert('Please select an AI to start the game.');
                    return;
                }

                fetch('/Home/SelectAI', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': requestVerificationToken
                    },
                    body: JSON.stringify({ AIName: aiName })
                })
                    .then(response => {
                        if (response.ok) {
                            window.location.reload();
                        } else {
                            throw new Error('Failed to select AI.');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred while selecting the AI.');
                    });
            }

            function setGameMode(mode) {
                fetch('/Home/SetGameMode', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': requestVerificationToken
                    },
                    body: JSON.stringify({ GameMode: mode })
                })
                    .then(response => {
                        if (response.ok) {
                            window.location.reload();
                        } else {
                            throw new Error('Failed to set game mode.');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred while setting the game mode.');
                    });
            }

            // Debounce function to limit the rate at which a function can fire.
            function throttle(fn, limit) {
                let lastFunc;
                let lastRan;
                return function (...args) {
                    const context = this;
                    if (!lastRan) {
                        fn.apply(context, args);
                        lastRan = Date.now();
                    } else {
                        clearTimeout(lastFunc);
                        lastFunc = setTimeout(function () {
                            if ((Date.now() - lastRan) >= limit) {
                                fn.apply(context, args);
                                lastRan = Date.now();
                            }
                        }, limit - (Date.now() - lastRan));
                    }
                }
            }

            // Expose functions to global scope
            window.restartGame = restartGame;
            window.selectAIAndStartGame = selectAIAndStartGame;
            window.setGameMode = setGameMode;
        })();
    </script>

    @functions {
        private string GetPieceSymbol(Piece piece)
        {
            if (piece is Pawn)
                return piece.IsWhite ? "♙" : "♟";
            else if (piece is Rook)
                return piece.IsWhite ? "♖" : "♜";
            else if (piece is Knight)
                return piece.IsWhite ? "♘" : "♞";
            else if (piece is Bishop)
                return piece.IsWhite ? "♗" : "♝";
            else if (piece is Queen)
                return piece.IsWhite ? "♕" : "♛";
            else if (piece is King)
                return piece.IsWhite ? "♔" : "♚";
            else
                return "";
        }
    }

</body>
</html>